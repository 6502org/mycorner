<HTML><HEAD><TITLE>Enhanced BASIC language reference</TITLE>
<META name="description" content="An advanced BASIC interpreter for the 6502
 microprocessor."></HEAD>
<BODY BACKGROUND="../../back.png" LINK="#0000EE" VLINK="#0000CC">
<TABLE BORDER=0 WIDTH=100% CELLSPACING=0 CELLPADDING=0><TR><TD WIDTH=20%>
<A HREF="index.html#link_1"><IMG SRC="../../up.gif" BORDER=0 TITLE="Up one"></A></TD>
<TD WIDTH=60% ALIGN=CENTER><B><FONT SIZE=+1>Enhanced BASIC language reference </FONT></B>
<FONT SIZE=-1>By Lee Davison.</FONT></TD><TD WIDTH=20%><A HREF="../../index.html">
 <IMG SRC="../../epc.png" ALIGN=RIGHT BORDER=0 TITLE="Up to top"></A></TD></TR></TABLE>
<HR>
<B><U>Numbers</U></B>
<BLOCKQUOTE><P ALIGN=JUSTIFY>
  Numbers may range from zero to plus or minus 1.70141173x10^38 and will have an
  accuracy of just under 1 part in 1.68 x 10^7.
<P ALIGN=JUSTIFY>
  Numbers can be preceded by a sign, + or -, and are written as a string of
  numeric digits with or without a decimal point and can also have a positive
  or negative exponent as a power of 10 multiplier e.g.
<P ALIGN=JUSTIFY>
  <CENTER>
    <TABLE WIDTH=85% CELLPADDING=3 CELLSPACING=0 BORDER=0>
      <TR>
        <TD>-142</TD> 
        <TD>96.3</TD> 
        <TD>0.25</TD> 
        <TD>-136.42E-3</TD>
        <TD>-1.3E7</TD> 
        <TD>1</TD> 
      </TR>
    </TABLE>
  </CENTER>
<P ALIGN=JUSTIFY>
  .. are all valid numbers.
<P ALIGN=JUSTIFY>
  Integer numbers, i.e. with no decimal fraction or exponent, can also be in
  either hexadecimal or binary. Hexadecimal numbers should be preceded by <B>$</B>
  and binary numbers preceded by <B>%</B>, e.g.
<P ALIGN=JUSTIFY>
  <CENTER>
    <TABLE WIDTH=85% CELLPADDING=3 CELLSPACING=0 BORDER=0>
      <TR>
        <TD>%101010</TD> 
        <TD>-$FFE0</TD> 
        <TD>$A0127BD</TD> 
        <TD>-%10011001</TD> 
        <TD>%00001010</TD>
        <TD>$0A</TD> 
      </TR>
    </TABLE>
  </CENTER>
<P ALIGN=JUSTIFY>
  .. again are all valid numbers.
</BLOCKQUOTE>
<B><U>Strings</U></B>
<BLOCKQUOTE><P ALIGN=JUSTIFY>
  Strings are any string of printable characters enclosed in a pair of quotation marks.
  Non printing characters may be converted to single character strings using the
  <A href="#CHR">CHR$()</A> functions.
<P ALIGN=JUSTIFY>
  <CENTER>
    <TABLE WIDTH=85% CELLPADDING=3 CELLSPACING=0 BORDER=0>
      <TR>
        <TD>"Hello world"</TD> 
        <TD>"-136.42E-3"</TD> 
        <TD>"+----+----+"</TD> 
        <TD>"[Y/n]"</TD> 
        <TD>"Y"</TD> 
      </TR>
    </TABLE>
  </CENTER>
<P ALIGN=JUSTIFY>
  Are all valid strings.
</BLOCKQUOTE>
<B><U>Variables</U></B>
<BLOCKQUOTE><P ALIGN=JUSTIFY>
  Variables of both numeric and string type are available. String variables are
  distinguished by the <B>$</B> suffix. As well as simple variables arrays are also
  available and these may be either numeric or string and are distinguished by their
  bracketed indicies after the variable name.
<P ALIGN=JUSTIFY>
  Variable names may be any length but only the first two name characters are significant
  so BL and BLANK will refer to the same variable. The first character must be one of "A"
  to "Z" or "a" to "z", following characters may also include numbers. E.g.
<P ALIGN=JUSTIFY>
  <CENTER>
    <TABLE WIDTH=85% CELLPADDING=3 CELLSPACING=0 BORDER=0>
      <TR>
        <TD>A</TD> 
        <TD>A$</TD> 
        <TD>NAME$</TD>
        <TD>x2LIM</TD> 
        <TD>y</TD> 
        <TD>colour</TD>
        <TD>s1</TD> 
        <TD>s2</TD> 
      </TR>
    </TABLE>
  </CENTER>
<P ALIGN=JUSTIFY>
  Variable names are case sensitive so AB, Ab, aB and ab are all separate variables.
<P ALIGN=JUSTIFY>
  Variable names may not contain BASIC keywords. Keywords are only valid in upper
  case so 'PRINTER' is not allowed (it would be interpreted as PRINT ER) but 'printer'
  is.
<P ALIGN=JUSTIFY>
  Note that spaces in variable names are ignored so 'print e r', 'print er' and 'pri nter'
  will all be interpreted the same way.
</BLOCKQUOTE>

<B><U>BASIC Keywords</B></U>
<BLOCKQUOTE><P ALIGN=JUSTIFY>
  Here is a list of BASIC keywords. They are only valid when entered in upper case as
  shown and spaces may not be included in them. So GOTO is valid BASIC keyword but GO TO
  is not.
<P ALIGN=JUSTIFY>
  <CENTER>
    <TABLE WIDTH=85% CELLPADDING=3 CELLSPACING=0 BORDER=0>
    <TR>
      <TD><A href="#ABS">ABS</A></TD>
      <TD><A href="#AND">AND</A></TD>
      <TD><A href="#ASC">ASC</A></TD>
      <TD><A href="#ATN">ATN</A></TD>
      <TD><A href="#BIN">BIN$</A></TD>
      <TD><A href="#BITCLR">BITCLR</A></TD>
      <TD><A href="#BITSET">BITSET</A></TD>
    </TR>
    <TR>
      <TD><A href="#BITTST">BITTST</A></TD>
      <TD><A href="#CALL">CALL</A></TD>
      <TD><A href="#CHR">CHR$</A></TD>
      <TD><A href="#CLEAR">CLEAR</A></TD>
      <TD><A href="#CONT">CONT</A></TD>
      <TD><A href="#COS">COS</A></TD>
      <TD><A href="#DATA">DATA</A></TD>
    </TR>
    <TR>
      <TD><A href="#DEC">DEC</A></TD>
      <TD><A href="#DEEK">DEEK</A></TD>
      <TD><A href="#DEF">DEF</A></TD>
      <TD><A href="#DIM">DIM</A></TD>
      <TD><A href="#DO">DO</A></TD>
      <TD><A href="#DOKE">DOKE</A></TD>
      <TD><A href="#ELSE">ELSE</A></TD>
    </TR>
    <TR>
      <TD><A href="#END">END</A></TD>
      <TD><A href="#AND">EOR</A></TD>
      <TD><A href="#EXP">EXP</A></TD>
      <TD><A href="#FN">FN</A></TD>
      <TD><A href="#FOR">FOR</A></TD>
      <TD><A href="#FRE">FRE</A></TD>
      <TD><A href="#GET">GET</A></TD>
    </TR>
    <TR>
      <TD><A href="#GOSUB">GOSUB</A></TD>
      <TD><A href="#GOTO">GOTO</A></TD>
      <TD><A href="#HEX">HEX$</A></TD>
      <TD><A href="#IF">IF</A></TD>
      <TD><A href="#INC">INC</A></TD>
      <TD><A href="#INPUT">INPUT</A></TD>
      <TD><A href="#INT">INT</A></TD>
    </TR>
    <TR>
      <TD><A href="#IRQ">IRQ</A></TD>
      <TD><A href="#LCASE">LCASE$</A></TD>
      <TD><A href="#LEFT">LEFT$</A></TD>
      <TD><A href="#LEN">LEN</A></TD>
      <TD><A href="#LET">LET</A></TD>
      <TD><A href="#LIST">LIST</A></TD>
      <TD><A href="#LOAD">LOAD</A></TD>
    </TR>
    <TR>
      <TD><A href="#LOG">LOG</A></TD>
      <TD><A href="#LOOP">LOOP</A></TD>
      <TD><A href="#MAX">MAX</A></TD>
      <TD><A href="#MID">MID$</A></TD>
      <TD><A href="#MIN">MIN</A></TD>
      <TD><A href="#NEW">NEW</A></TD>
      <TD><A href="#NEXT">NEXT</A></TD>
    </TR>
    <TR>
      <TD><A href="#NMI">NMI</A></TD>
      <TD><A href="#NOT">NOT</A></TD>
      <TD><A href="#NULL">NULL</A></TD>
      <TD><A href="#OFF">OFF</A></TD>
      <TD><A href="#ON">ON</A></TD>
      <TD><A href="#AND">OR</A></TD>
      <TD><A href="#PEEK">PEEK</A></TD>
    </TR>
    <TR>
      <TD><A href="#PI">PI</A></TD>
      <TD><A href="#POKE">POKE</A></TD>
      <TD><A href="#POS">POS</A></TD>
      <TD><A href="#PRINT">PRINT</A></TD>
      <TD><A href="#READ">READ</A></TD>
      <TD><A href="#REM">REM</A></TD>
      <TD><A href="#RESTORE">RESTORE</A></TD>
    </TR>
    <TR>
      <TD><A href="#RETIRQ">RETIRQ</A></TD>
      <TD><A href="#RETNMI">RETNMI</A></TD>
      <TD><A href="#RETURN">RETURN</A></TD>
      <TD><A href="#RIGHT">RIGHT$</A></TD>
      <TD><A href="#RND">RND</A></TD>
      <TD><A href="#RUN">RUN</A></TD>
      <TD><A href="#SADD">SADD</A></TD>
    </TR>
    <TR>
      <TD><A href="#SAVE">SAVE</A></TD>
      <TD><A href="#SIN">SIN</A></TD>
      <TD><A href="#SGN">SGN</A></TD>
      <TD><A href="#SPC">SPC(</A></TD>
      <TD><A href="#SQR">SQR</A></TD>
      <TD><A href="#STEP">STEP</A></TD>
      <TD><A href="#STOP">STOP</A></TD>
    </TR>
    <TR>
      <TD><A href="#STR">STR$</A></TD>
      <TD><A href="#SWAP">SWAP</A></TD>
      <TD><A href="#TAB">TAB(</A></TD>
      <TD><A href="#TAN">TAN</A></TD>
      <TD><A href="#THEN">THEN</A></TD>
      <TD><A href="#TO">TO</A></TD>
      <TD><A href="#TWOPI">TWOPI</A></TD>
    </TR>
    <TR>
      <TD><A href="#UCASE">UCASE$</A></TD>
      <TD><A href="#UNTIL">UNTIL</A></TD>
      <TD><A href="#USR">USR</A></TD>
      <TD><A href="#VAL">VAL</A></TD>
      <TD><A href="#VARPTR">VARPTR</A></TD>
      <TD><A href="#WAIT">WAIT</A></TD>
      <TD><A href="#WHILE">WHILE</A></TD>
    </TR>
    <TR>
      <TD><A href="#WIDTH">WIDTH</A></TD>
      <TD><A href="#AND">+</A></TD>
      <TD><A href="#AND">-</A></TD>
      <TD><A href="#AND">*</A></TD>
      <TD><A href="#AND">/</A></TD>
      <TD><A href="#AND">^</A></TD>
      <TD><A href="#AND">&lt;&lt;</A></TD>
    </TR>
    <TR>
      <TD><A href="#AND">&gt;&gt;</A></TD>
      <TD><A href="#AND">&gt;</A></TD>
      <TD><A href="#AND">=</A></TD>
      <TD><A href="#AND">&lt;</A></TD>
    </TR>
    </TABLE>
  </CENTER>
 </BLOCKQUOTE>
 
  <UL>
    <LI>Anything in upper case is part of the command/function structure and must be present
    <LI>Anything in lower case enclosed in < > is to be supplied by the user
    <LI>Anything enclosed in [ ] is optional
    <LI>Anything enclosed in { } and separated by | characters are multi choice options
    <LI>Any items followed by an ellipsis, ... , may be repeated any number of times
    <LI>Any punctuation and symbols, except those above, are part of the structure and must
        be included
  </UL>

  <BLOCKQUOTE>
  <TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0>
  <TR><TD>var</TD><TD>is a valid variable name</TD></TR>
  <TR><TD>var$</TD><TD>is a valid string variable name</TD></TR>
  <TR><TD>var()</TD><TD>is a valid array name</TD></TR>
  <TR><TD>var$()</TD><TD>is a valid string array name</TD></TR>
  <TR><TD>&nbsp;</TD></TR>
  <TR><TD>expression</TD><TD>is any expression returning a result</TD></TR>
  <TR><TD>expression$&nbsp;&nbsp;&nbsp;</TD><TD>is any expression returning a string result</TD></TR>
  <TR><TD>&nbsp;</TD></TR>
  <TR><TD>addr</TD><TD>is an integer in the range +/- 16777215 that will be wrapped to the range 0 to 65535</TD></TR>
  <TR><TD>b</TD><TD>is a byte value 0 to 255</TD></TR>
  <TR><TD>n</TD><TD>is an integer in the range 0 to 63999</TD></TR>
  <TR><TD>w</TD><TD>is an integer in the range -32768 to 32767</TD></TR>
  <TR><TD>i</TD><TD>is a +ve integer value</TD></TR>
  <TR><TD>r</TD><TD>is real number</TD></TR>
  <TR><TD>+r</TD><TD>is a +ve value real number (0 is considered +ve)</TD></TR>
  <TR><TD>$</TD><TD>is a string literal</TD></TR>
  </TABLE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P><B><U>BASIC Commands</U></B>

<BLOCKQUOTE>
  <A name=ELSE></A>
  <B>ELSE</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    See <A href="#IF">IF</A>.
  </BLOCKQUOTE>

  <A name=END></A>
  <B>END</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Terminates program execution and returns control to the command line (direct mode).
    END may be placed anywhere in a program, it does not have to be on the last line, and
    there may be any number, including none, of ENDs in total.
<P ALIGN=JUSTIFY>
    Note. CONT may be used after and END to resume execution from the next statement.
  </BLOCKQUOTE>

  <A name=FOR></A>
  <B>FOR &lt;var&gt; = &lt;expression&gt; TO &lt;expression&gt; [STEP expression]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Assigns a variable to a loop counter and optionally sets the start value, the end
    value and the step size. If STEP expression is omitted then a default step size of
    +1 will be assumed.
  </BLOCKQUOTE>

  <A name=NEXT></A>
  <B>NEXT [var[,var]...]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Increments or decrements a loop variable and checks for the terminating condition. If
    the terminating condition has been reached then execution continues with the next
    command, else execution continues with the command after the FOR assignment. <I>See <A
    href="#FOR">FOR</A></I>.
  </BLOCKQUOTE>

  <A name=DATA></A>
  <B>DATA [{r|$}[,{r|$}]...]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Defines a constant or series of constants. Real constants are held as
    strings in program memory and can be read as numeric values or string
    values. String constants may contain spaces but if they need to contain
    commas then they must be enclosed in quotes.
  </BLOCKQUOTE>

  <A name=INPUT></A>
  <B>INPUT ["$";] &lt;var&gt;[,var]...</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Get a variable, or list of variables from the input stream. A question mark, "?", is
    always output, after the string if there is one, and if further input is required,
    i.e. there are more variables in the list than the user entered values, then a double
    question mark, "??", will be output until enough values have been entered.
<P ALIGN=JUSTIFY>
    There are two possible messages that may appear during the execution of an input
    statement:
    <BLOCKQUOTE><P ALIGN=JUSTIFY>
        <I><B>Extra ignored</B></I>
        <BLOCKQUOTE><P ALIGN=JUSTIFY>
	  The user has attempted to enter more values than are required. Program
  	  execution will continue but the extraneous data entered has been discarded.
        </BLOCKQUOTE>

        <I><B>Redo from start</B></I>
        <BLOCKQUOTE><P ALIGN=JUSTIFY>
	  The user has attempted to enter a string where a number was expected. The
  	  reverse never causes an error as numbers are also valid strings.
        </BLOCKQUOTE>
    </BLOCKQUOTE>
  </BLOCKQUOTE>

  <A name=DIM></A>
  <B>DIM &lt;var[$](i1[,i2[,in]...])&gt;[,var[$](i1[,i2[,in]...])]...</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Dimension arrays. Creates arrays of either string or numeric variables. The arrays
    can have one or more dimensions. The lower limit of any dimension is always
    zero and the upper limit is i. If you do not explicitly dimension an array then
    it's number of dimensions will be set when you first access it and the
    upper bound will be set to 10 for each dimension.
  </BLOCKQUOTE>

  <A name=READ></A>
  <B>READ &lt;var&gt;[,var]...</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Reads values from DATA statements and assigns them to variables. Trying to
    read a string literal into a numeric variable will cause a syntax error.
  </BLOCKQUOTE>

  <A name=LET></A>
  <B>LET &lt;var&gt; = &lt;expression&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Assign the value of expression to var. Both var and expression bust be of the
    same type. The LET command word is optional and just &lt;var&gt; = &lt;expression&gt;
    will give exactly the same result. It is only maintained for historical reasons.
  </BLOCKQUOTE>

  <A name=DEC></A>
  <B>DEC &lt;var&gt;[,var]...</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Decrement variables. The variables listed will have their values decremented
    by one. Trying to decrement a string variable will give a type mismatch error.
    DEC A is much faster than doing A=A-1 and DEC A,A is slightly faster than
    doing A=A-2.
  </BLOCKQUOTE>


  <A name=SWAP></A>
  <B>SWAP &lt;var[$]&gt;,&lt;var[$]&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Swap two variables. The variables listed will have their values exchanged. Both
    must be of the same type, numeric or string, and either, or both, may be array
    elements. Trying to swap a numeric and string variable will give a type mismatch
    error.
  </BLOCKQUOTE>

  <A name=GOTO></A>
  <B>GOTO &lt;n&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Continue execution from line number n
  </BLOCKQUOTE>


  <A name=RUN></A>
  <B>RUN [n]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Begins execution of the program currently in memory at the lowest numbered line.
    RUN erases all variables and functions, resets FOR .. NEXT, GOSUB .. RETURN and
    DO ..LOOP states and sets the data pointer to the program start.
  <P ALIGN=JUSTIFY>
    If n is specified then programme execution will start at the specified line number.
  </BLOCKQUOTE>

  <A name=IF></A>
  <B>IF &lt;expression&gt; {GOTO&lt;n&gt;|THEN&lt;{n|statement}&gt;}[ELSE&lt;{n|statement}&gt;]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Evaluates expression. If the result of expression is non zero then the GOTO or the
    statement after the THEN is executed. If the result of expression is zero then
    execution continues with the next line.
  <P ALIGN=JUSTIFY>
    If the result of expression is zero and the optional ELSE clause is included then
    the statement after the ELSE is executed.
  <P ALIGN=JUSTIFY>
    IF .. THEN .. ELSE .. behaves as a single statement so in the line ..
  <BLOCKQUOTE><TT>
      IF &lt;expression&gt; THEN &lt;statement one&gt; ELSE &lt;statement two&gt; : &lt;statement three&gt;
  </TT></BLOCKQUOTE>
    .. statement three will always be executed regardless of the outcome of the IF
    as long as the executed statement was not a GOTO
  </BLOCKQUOTE>

  <A name=RESTORE></A>
  <B>RESTORE [n]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Reset the DATA pointer. If n is specified then the pointer will be reset to the
    beginning of line n else it will be reset to the start of the program. If n is
    specified but doesn't exist an error will be generated.
  </BLOCKQUOTE>

  <A name=GOSUB></A>
  <B>GOSUB &lt;n&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Call a subroutine at line n. Program execution is diverted to line n but the
    calling point is remembered. Upon encountering a RETURN statement program
    execution will continue with the next statement (line) after the GOSUB.
  </BLOCKQUOTE>

  <A name=RETIRQ></A>
  <B>RETIRQ</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns program execution to the next statement after an interrupt, automatically
    restores the IRQ enabled flag. See <A href="#ON2">ON IRQ</A>.
  </BLOCKQUOTE>

  <A name=RETNMI></A>
  <B>RETNMI</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns program execution to the next statement after an interrupt, automatically
    restores the NMI enabled flag. See <A href="#ON2">ON NMI</A>.
  </BLOCKQUOTE>

  <A name=RETURN></A>
  <B>RETURN</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
     Returns program execution to the next statement (line) after the last GOSUB
     encountered. See <A href="#GOSUB">GOSUB</A>. Also returns program execution to the
     next statement after an interrupt but does not restore the enabled flags.
  </BLOCKQUOTE>

  <A name=REM></A>
  <B>REM</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Everything following this statement on this program line will be ignored,
    even colons.
  </BLOCKQUOTE>

  <A name=STOP></A>
  <B>STOP</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Halts program execution and generates a "Break in line n" message where n is the
    line in which the STOP was encountered.
  </BLOCKQUOTE>

  <A name=OFF></A>
  <B>OFF</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    See <A href="#IRQ">IRQ</A> or <A href="#NMI">NMI</A>.
  </BLOCKQUOTE>

  <A name=ON></A>
  <B>ON &lt;expression&gt; {GOTO|GOSUB} &lt;n&gt;[,n]...</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    The integer value of expression is calculated and then the nth number after the
    GOTO or GOSUB is taken (where n is the result of expression). Note that valid
    results for expression range only from zero to 255. Any result outside this
    range will cause a Function call error.
  </BLOCKQUOTE>

  <A name=ON2></A>
  <B>ON {IRQ|NMI} &lt;n&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Set up the IRQ or NMI routine pointers. This sets up the effective GOSUB line
    that is taken when an interrupt happens. When the effective GOSUB is taken the
    interrupt, IRQ or NMI, is turned off. This can be turned back on with the interrupt
    on command or by using the matching special return. The normal program flow is
    resumed by any of RETIRQ, RETNMI or RETURN.
  </BLOCKQUOTE>

  <A name=NULL></A>
  <B>NULL &lt;n&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Sets the number of null characters printed by BASIC after every carriage 
    return. n may be specified in the range 0 to 255.
  </BLOCKQUOTE> 

  <A name=INC></A>
  <B>INC &lt;var&gt;[,var]...</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Increment variables. The variables listed will have their values incremented
    by one. Trying to increment a string variable will give a type mismatch error.
    INC A is much faster than doing A=A+1 and INC A,A is slightly faster than
    doing A=A+2.
  </BLOCKQUOTE>

  <A name=WAIT></A>
  <B>WAIT &lt;addr,b1&gt;[,b2]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Program execution will wait at this point until the value of the location addr
    exclusive ORed with b2 then ANDed with b1 is non zero. If b2 is not defined then
    it is assumed to be zero. Note b1 and b2 must both be byte values.
  </BLOCKQUOTE>

  <A name=LOAD></A>
  <B>LOAD</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Does nothing in this version but does it via a vector in RAM so is easily patched.
  </BLOCKQUOTE>

  <A name=SAVE></A>
  <B>SAVE</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Does nothing in this version but does it via a vector in RAM so is easily patched.
  </BLOCKQUOTE>

  <A name=DEF></A>
  <B>DEF FN &lt;name&gt;(&lt;var&gt;) = &lt;statement&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Defines &lt;statement&gt; as function &lt;name&gt;. &lt;name&gt; can be any valid
    numeric variable name of one or more characters. &lt;var&gt; must be a simple
    variable and is used to pass a numeric argument into the function.
  <P ALIGN=JUSTIFY>
    Note that the value of &lt;var&gt; will be unchanged if it is used in the function
    so &lt;var&gt; should be considered to be a local variable name.
  </BLOCKQUOTE>

  <A name=POKE></A>
  <B>POKE &lt;addr,b&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Writes the byte value b into the address addr.
  </BLOCKQUOTE>

  <A name=DOKE></A>
  <B>DOKE &lt;addr,w&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Writes the word value w into the addresses addr and addr+1, the lower byte of
    w is in addr. Note if addr = 65535 ($FFFF) then the high byte will be written
    to address zero.
  </BLOCKQUOTE>

  <A name=CALL></A>
  <B>CALL &lt;addr&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    CALLs a user subroutine at address addr. No values are passed or returned and
    so this is much faster than using USR()
  </BLOCKQUOTE>

  <A name=DO></A>
  <B>DO</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Marks the beginning of a DO .. LOOP loop (See <A href="#LOOP">LOOP</A>). No parameters. This
    command can be nested like FOR .. NEXT or GOSUB .. RETURN.
  </BLOCKQUOTE>

  <A name=LOOP></A>
  <B>LOOP [{UNTIL|WHILE} expression]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Marks the end of a DO .. LOOP loop. There are three possible variations on the
    LOOP command ..
    
    <BLOCKQUOTE><P ALIGN=JUSTIFY>
        <B>LOOP</B>
        <BLOCKQUOTE><P ALIGN=JUSTIFY>
          This loop repeats forever. With just this command control is passed back to the
          next command after the corresponding DO.
        </BLOCKQUOTE>
<P ALIGN=JUSTIFY>
        <B>LOOP UNTIL expression</B>
        <BLOCKQUOTE><P ALIGN=JUSTIFY>
          This loop will repeat until the value of expression is non zero. Once that
          occurs execution will continue with the next command after the LOOP UNTIL.
        </BLOCKQUOTE>
<P ALIGN=JUSTIFY>
        <B>LOOP WHILE expression</B>
        <BLOCKQUOTE><P ALIGN=JUSTIFY>
          This loop will repeat while the value of expression is non zero. When the
          value of expression is zero execution will continue with the next command
          after the LOOP WHILE.
        </BLOCKQUOTE>
    </BLOCKQUOTE>
  </BLOCKQUOTE>

  <A name=PRINT></A>
  <B>PRINT [expression][{;|,}expression]...[{;|,}]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Outputs the value of each expressions. If the list of expressions to  be output
    does not end with a comma or a semi-colon, then a carriage return and linefeed
    is output after the values. 
<P ALIGN=JUSTIFY>
    Expressions on the line can be separated with either a semi-colon, causing the
    next expression to follow immediately, or a comma which will advance the output
    to the next tab stop before continuing to print. If there are no expressions and
    no comma or semi-colon after the PRINT statement then a carriage return and
    linefeed is output.
<P ALIGN=JUSTIFY>
    When entering a program line, or immediate statement, PRINT can be abbreviated to ?
  </BLOCKQUOTE>

  <A name=CONT></A>
  <B>CONT</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Continues program execution after CTRL-C has been typed, a STOP has been encountered
    during program execution or a null input was given to an INPUT request.
  </BLOCKQUOTE>

  <A name=LIST></A>
  <B>LIST [n1][-n2]</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Lists the entire program held in memory. If n1 is specified then the listing will
    start from line n1 and run to the end of the program. If -n2 is specified then the
    listing will terminate after line n2 has been listed. If n1 and -n2 are specified
    then all the lines from n1 to n2 inclusive will be listed.
<P ALIGN=JUSTIFY>
    Note. If n1 does not exist then the list will start from the next line numbered
    after n1. If n2 does not exist then the listing will stop with the last line
    numbered before n2.
<P ALIGN=JUSTIFY>
    Also note. LIST can be executed from within a program, first a [CR][LF] is printed
    and then the specified lines, if any, each terminated with another [CR][LF].
    Program execution then continues as normal.

  </BLOCKQUOTE>

  <A name=CLEAR></A>
  <B>CLEAR</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Erases all variables and functions and resets FOR .. NEXT, GOSUB .. RETURN and
    DO ..LOOP states.
  </BLOCKQUOTE>

  <A name=NEW></A>
  <B>NEW</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Deletes the current program and all variables from memory.
  </BLOCKQUOTE>

  <A name=WIDTH></A>
  <B>WIDTH {b1|,b2|b1,b2}</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Sets the terminal width and TAB spacing. b1 is the terminal width and b2 is the tab
    spacing, default is 80 and 14. Width can be zero, for "infinite" terminal width, or
    from 16 to 255. The tab size is from 2 to width-1 or 127, whichever is smaller.
  </BLOCKQUOTE>

  <A name=GET></A>
  <B>GET &lt;var[$]&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Gets a key, if there is one, from the input device. If there is no key waiting then
    var will be set to 0 and var$ will return a null string "". GET does not halt and
    execution will continue.
  </BLOCKQUOTE>

  <A name=IRQ></A>
  <B>IRQ {ON|OFF|CLEAR}</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Enables or disables the IRQ handling subroutine. Note that turning the handler off
    does not suppress the interrupt detection and if an interrupt occurs while handling is
    off it will be actioned as soon as handling is turned back on. Using CLEAR clears the
    interrupt assignment and it can only be restarted with an ON IRQ command
  </BLOCKQUOTE>

  <A name=NMI></A>
  <B>NMI {ON|OFF|CLEAR}</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Enables or disables the NMI handling subroutine. Note that turning the handler off
    does not suppress the interrupt detection and if an interrupt occurs while handling is
    off it will be actioned as soon as handling is turned back on. Using CLEAR clears the
    interrupt assignment and it can only be restarted with an ON NMI command
  </BLOCKQUOTE>

  <A name=TAB></A>
  <B>TAB(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Sets the cursor position to &lt;expression&gt;. If the cursor is already beyond that
    point then the cursor will be left where it is. This command is only valid in a
    PRINT statement.
  </BLOCKQUOTE>

  <A name=TO></A>
  <B>TO</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Sets the range in a FOR .. NEXT loop. See <A href="#FOR">FOR</A>.
  </BLOCKQUOTE>

  <A name=FN></A>
  <B>FN&lt;name&gt;(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    See <A href="#DEF">DEF</A>.
  </BLOCKQUOTE>

  <A name=SPC></A>
  <B>SPC(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Prints &lt;expression&gt; spaces. This command is only valid in a PRINT statement.
  </BLOCKQUOTE>

  <A name=THEN></A>
  <B>THEN</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    See <A href="#IF">IF</A>.
  </BLOCKQUOTE>

  <A name=NOT></A>
  <B>NOT &lt;expression&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Generates the bitwise NOT of then signed integer value of &lt;expression&gt;.
  </BLOCKQUOTE>

  <A name=STEP></A>
  <B>STEP</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Sets the step size in a FOR .. NEXT loop. See <A href="#FOR">FOR</A>.
  </BLOCKQUOTE>

  <A name=UNTIL></A>
  <B>UNTIL</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    See <A href="#DO">DO</A> and <A href="#LOOP">LOOP</A>.
  </BLOCKQUOTE>

  <A name=WHILE></A>
  <B>WHILE</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    See <A href="#DO">DO</A> and <A href="#LOOP">LOOP</A>.
  </BLOCKQUOTE>

  <A name=BITCLR></A>
  <B>BITCLR &lt;addr&gt;,&lt;b&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Clears bit b of address addr. Valid bit numbers are 0, the least significant bit, to
    7, the most significant bit. Values outside this range will cause a function call
    error.
  </BLOCKQUOTE>

  <A name=BITSET></A>
  <B>BITSET &lt;addr&gt;,&lt;b&gt;</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Sets bit b of address addr. Valid bit numbers are 0, the least significant
    bit, to 7, the most significant bit. Values outside this range will cause a
    function call error.
  </BLOCKQUOTE>
</BLOCKQUOTE>

<P><B><U>BASIC Operators</B></U>
<BLOCKQUOTE><P ALIGN=JUSTIFY>
  Operators perform mathematical or logical operations on values and return the result.
  The operation is usually preceded by a variable name and equality sign or is part of
  an IF .. THEN statement.
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    <A name=AND></A>
    <TABLE CELLPADDING=3 CELLSPACING=0 BORDER=0>
    <TR><TD>+</TD><TD>Add. c = a + b will assign the sum of a and b to c.</TD></TR>
    <TR><TD>-</TD><TD>Subtract. c = a - b will assign the result of a minus b to c.</TD></TR>
    <TR><TD>*</TD><TD>Multiply. c = a * b will assign the product of a and b to c.</TD></TR>
    <TR><TD>/</TD><TD>Divide. c = a / b will assign the result of a divided by b to c.</TD></TR>
    <TR><TD>^</TD><TD>Raise to the power of.  c = a ^ b will assign the result of a raised to the power of b to c.</TD></TR>
    <TR><TD>AND</TD><TD>Logical AND. c = a AND b will assign the logical AND of a and b to c</TD></TR>
    <TR><TD>EOR</TD><TD>Logical Exclusive OR.  c = a EOR b will assign the logical exclusive OR of a and b to c.</TD></TR>
    <TR><TD>OR</TD><TD>Logical OR.  c = a OR b will assign the logical inclusive OR of a and b to c.</TD></TR>
    <TR><TD>&lt;&lt;</TD><TD>Shift left.  c = a &lt;&lt; b will assign the result of a shifted left by b bits to c.</TD></TR>
    <TR><TD>&gt;&gt;</TD><TD>Shift right.  c = a &gt;&gt; b will assign the result of a shifted right by b bits to c.</TD></TR>
    <TR><TD>=</TD><TD>Equals.  c = a = b will assign the result of the comparison a = b to c.</TD></TR>
    <TR><TD>&gt;</TD><TD>Greater than.  c = a &lt; b will assign the result of the comparison a &gt; b to c.</TD></TR>
    <TR><TD>&lt;</TD><TD>Less than.  c = a &lt; b will assign the result of the comparison of a &lt; b to c.</TD></TR>
    </TABLE>
  </BLOCKQUOTE>

  The three comparison operators can be mixed to provide further operators ..
  <BLOCKQUOTE>
     <TABLE CELLPADDING=3 CELLSPACING=0 BORDER=0>
     <TR><TD>&gt;= or =&gt;</TD><TD>Greater than or equal to.</TD></TR>
     <TR><TD>&lt;= or =&lt;</TD><TD>Less than or equal to.</TD></TR>
      <TR><TD>&lt;&gt; or &gt;&lt;</TD><TD>Not equal to (greater than or less than).</TD></TR>
     <TR><TD>&lt;=&gt; any order</TD><TD>Always true (greater than or equal to or less than).</TD></TR>
     </TABLE>
  </BLOCKQUOTE>
</BLOCKQUOTE>

<B><U>BASIC Functions</U></B>
<BLOCKQUOTE><P ALIGN=JUSTIFY>
  Functions always return a value, be it numeric or string, so are used on the right hand
  side of the = sign in assignments, on either side of operators and in commands requiring
  an expression e.g. after PRINT, within expressions, or in other functions.

<P ALIGN=JUSTIFY><A name=SGN></A>
  <B>SGN(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the sign of &lt;expression&gt;. If the value is +ve SGN returns +1, if
    the value is -ve then SGN returns -1. If expression=0 then SGN returns 0.
  </BLOCKQUOTE>

  <A name=INT></A>
  <B>INT(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the integer of &lt;expression&gt;.
  </BLOCKQUOTE>

  <A name=ABS></A>
  <B>ABS(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the absolute value of &lt;expression&gt;.
  </BLOCKQUOTE>

  <A name=USR></A>
  <B>USR(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Takes the value of &lt;expression&gt; and places it in FAC1 and then calls the
    USeR routine pointed to by the vector at $0B,$0C. What the routine does
    with this value is entirely up to the user, it can even be safely ignored
    if it isn't needed. The routine, after the user code has done an RTS, takes
    whatever is in FAC1 and returns that. Note it can be either a numeric or
    string value.
<P ALIGN=JUSTIFY>
    If no value needs to be passed or returned then CALL is a better option.
  </BLOCKQUOTE>

  <A name=FRE></A>
  <B>FRE(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the amount of free program memory. The value of expression is ignored
    and can be numeric or string.
  </BLOCKQUOTE>

  <A name=POS></A>
  <B>POS(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the POSition of the cursor on the terminal line. The value of expression
    is ignored.
  </BLOCKQUOTE>

  <A name=SQR></A>
  <B>SQR(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the square root of &lt;expression&gt;.
  </BLOCKQUOTE>

  <A name=RND></A>
  <B>RND(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns a random number in the range 0 to 1. If the value of &lt;expression&gt; is
    non zero then it will be used as the seed for the returned pseudo random number
    otherwise the next number in the sequence will be returned.
  </BLOCKQUOTE>

  <A name=LOG></A>
  <B>LOG(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the natural logarithm (base e) of &lt;expression&gt;.
  </BLOCKQUOTE>

  <A name=EXP></A>
  <B>EXP(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns e^&lt;expression&gt;. Natural antilog.
  </BLOCKQUOTE>

  <A name=COS></A>
  <B>COS(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the cosine of the angle &lt;expression&gt; radians.
  </BLOCKQUOTE>

  <A name=SIN></A>
  <B>SIN(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the sine of the angle &lt;expression&gt; radians.
  </BLOCKQUOTE>

  <A name=TAN></A>
  <B>TAN(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the tangent of the angle &lt;expression&gt; radians.
  </BLOCKQUOTE>

  <A name=ATN></A>
  <B>ATN(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns, in radians, the arctangent of &lt;expression&gt;.
  </BLOCKQUOTE>

  <A name=PEEK></A>
  <B>PEEK(&lt;addr&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the byte value of &lt;addr&gt;.
  </BLOCKQUOTE>

  <A name=DEEK></A>
  <B>DEEK(&lt;addr&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the word value of &lt;addr&gt; and addr+1 as an integer in the range -32768
    to 32767. Addr holds the word low byte.
  </BLOCKQUOTE>

  <A name=SADD></A>
  <B>SADD(&lt;{var$|var$()}&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the address of var$ or var$(). This returns a pointer to the actual string
    in memory not the descriptor. If you want the pointer to the descriptor use
    <A href="#VARPTR">VARPTR</A> instead.
  </BLOCKQUOTE>

  <A name=LEN></A>
  <B>LEN(&lt;expression$&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the length of &lt;expression$&gt;.
  </BLOCKQUOTE>

  <A name=STR></A>
  <B>STR$(&lt;expression&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the result of &lt;expression&gt; as a string.
  </BLOCKQUOTE>

  <A name=VAL></A>
  <B>VAL(&lt;expression$&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the value of &lt;expression$&gt;.
  </BLOCKQUOTE>

  <A name=ASC></A>
  <B>ASC(&lt;expression$&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the ASCII value of the first character of &lt;expression$&gt;.
  </BLOCKQUOTE>

  <A name=LCASE></A>
  <B>LCASE$(&lt;expression$&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns &lt;expression$&gt; with all the alpha characters in lower case.
  </BLOCKQUOTE>

  <A name=UCASE></A>
  <B>UCASE$(&lt;expression$&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns &lt;expression$&gt; with all the alpha characters in upper case.
  </BLOCKQUOTE>

  <A name=CHR></A>
  <B>CHR$(b)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns single character string of character &lt;b&gt;.
  </BLOCKQUOTE>

  <A name=HEX></A>
  <B>HEX$(&lt;expression&gt;[,b])</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns &lt;expression&gt; as a hex string. If b is omitted, or if b = 0, then
    the string is returned with all leading zeroes removed and is of variable length.
    If b is set, permissible values range from 1 to 6, then a string of length b will
    be returned. The result is always unsigned and calling this function with expression
    &gt; 2^24-1 or b &gt; 6 will cause a function call error.
  </BLOCKQUOTE>

  <A name=BIN></A>
  <B>BIN$(&lt;expression&gt;[,b])</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns &lt;expression&gt; as a binary string. If b is omitted, or if b = 0, then
    the string is returned with all leading zeroes removed and is of variable length.
    If b is set, permissible values range from 1 to 24, then a string of length b will
    be returned. The result is always unsigned and calling this function with expression
    &gt; 2^24-1 or b &gt; 24 will cause a function call error.
  </BLOCKQUOTE>

  <A name=BITTST></A>
  <B>BITTST(&lt;addr&gt;,&lt;b&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Tests bit b of address addr. Valid bit numbers are 0, the least significant bit, to 7,
    the most significant bit. Values outside this range will cause a function call error.
    Returns zero if the bit was zero, returns -1 if the bit was 1.
  </BLOCKQUOTE>

  <A name=MAX></A>
  <B>MAX(&lt;expression&gt;[,&lt;expression&gt;]...)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the maximum value from a list of numeric expressions. There must be
    at least one expression but the upper limit is dictated by the line length.
    Each expression is evaluated in turn and the largest of them returned.
  </BLOCKQUOTE>

  <A name=MIN></A>
  <B>MIN(&lt;expression&gt;[,&lt;expression&gt;]...)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the minimum value from a list of numeric expressions. There must be
    at least one expression but the upper limit is dictated by the line length.
    Each expression is evaluated in turn and the smallest of them returned.
  </BLOCKQUOTE>

  <A name=PI></A>
  <B>PI</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the value of pi as 3.14159274 (closest floating value).
  </BLOCKQUOTE>

  <A name=TWOPI></A>
  <B>TWOPI</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the value of 2*pi as 6.28318548 (closest floating value).
  </BLOCKQUOTE>

  <A name=VARPTR></A>
  <B>VARPTR(&lt;var[$]&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns a pointer to the variable memory space. If the variable is numeric, or a
    numeric array element, then VARPTR returns the pointer to the packed value of that
    variable in memory. If the variable is a string, or a string array element, then
    VARPTR returns a pointer to the descriptor for that string. If you want the pointer
    to the string itself use <A href="#SADD">SADD</A> instead.
  </BLOCKQUOTE>

  <A name=LEFT></A>
  <B>LEFT$(&lt;expression$,b&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the leftmost b characters of &lt;expression$&gt;.
  </BLOCKQUOTE>

  <A name=RIGHT></A>
  <B>RIGHT$(&lt;expression$,b&gt;)</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the rightmost b characters of &lt;expression$&gt;.
  </BLOCKQUOTE>

  <A name=MID></A>
  <B>MID$(&lt;expression$,b1&gt;[,b2])</B>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Returns the substring string from character b1 of expression$ of length b2. The
    characters of expression$ are numbered from 1 starting with the leftmost. If b2 is
    omitted then all the characters from b1 to the end of the string are returned.
  </BLOCKQUOTE>
</BLOCKQUOTE>

<B><U>BASIC Error Messages</U></B>
<BLOCKQUOTE><P ALIGN=JUSTIFY>
  These all occur from time to time and, if the error occurred while executing a program,
  will be followed by "in line <n>" where <n> is the number of the line in which the error
  occurred.
<P ALIGN=JUSTIFY>
  <I><B>NEXT without FOR Error</B></I> 
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    NEXT has been encountered and no matching FOR could be found.
  </BLOCKQUOTE>

  <I><B>Syntax Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Just generally worng. 8^)=
  </BLOCKQUOTE>

  <I><B>RETURN without GOSUB Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    RETURN has been encountered and no matching GOSUB could be found.
  </BLOCKQUOTE>

  <I><B>Out of DATA Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    A READ has tried to read data beyond the last item. Usually because you either
    mistyped the DATA lines, miscounted the DATA, RESTOREd to the wrong place or
    just plain forgot to restore.
  </BLOCKQUOTE>

  <I><B>Function call Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Some parameter of a function was outside it's limits. E.g. Trying to POKE a
    value of less than 0 or greater than 255.
  </BLOCKQUOTE>

  <I><B>Overflow Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    The result of a calculation has exceeded the numerical range of BASIC. This is
    plus or minus 1.7014117+E38
  </BLOCKQUOTE>

  <I><B>Out of memory Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Anything that uses memory can cause this but mostly it's writing and running
    programmes that does it.
  </BLOCKQUOTE>

  <I><B>Undefined statement Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Either a GOTO, GOSUB, RUN or RESTORE was attempted to a line that doesn't exist
    or the line referred to in an ON &lt;expression&gt; {GOTO|GOSUB} or ON {IRQ|NMI} <n>
    doesn't exist.
  </BLOCKQUOTE>

  <I><B>Array bounds Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    An attempt was made to access an element of an array that was outside it's
    bounding dimensions.
  </BLOCKQUOTE>

  <I><B>Double dimension Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    An attempt has been made to dimension an already dimensioned array. This could
    be because the array was accessed previously causing it to be dimensioned by
    default.
  </BLOCKQUOTE>

  <I><B>Divide by zero Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    The right hand side of an A/B expression was zero.
  </BLOCKQUOTE>

  <I><B>Illegal direct Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    An attempt was made to execute a command or function in direct mode which is
    disallowed in that mode e.g. INPUT or DEF.
  </BLOCKQUOTE>

  <I><B>Type mismatch Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    An attempt was made to assign a numeric value to a string variable, a string value to
    a numeric variable or a value of one type was returned when a value of the other type
    was expexted or an attempt at a relational operation between a string and a number
    was made.
  </BLOCKQUOTE>

  <I><B>String too long Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    String lengths can be from zero to 255 characters, more than that and you will
    see this.
  </BLOCKQUOTE>

  <I><B>String too complex Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    A string expression caused an overflow on the descriptor stack. Try splitting
    the expression into smaller pieces.
  </BLOCKQUOTE>

  <I><B>Can't continue Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    Execution can't be continued because either the program execution ended because
    an error occurred, NEW or CLEAR have been executed since the program was
    interrupted or the program has been edited.
  </BLOCKQUOTE>

  <I><B>Undefined function Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    FN &lt;var&gt; was called but not found.
  </BLOCKQUOTE>

  <I><B>LOOP without DO Error</B></I>
  <BLOCKQUOTE><P ALIGN=JUSTIFY>
    LOOP has been encountered and no matching DO could be found.
  </BLOCKQUOTE>
</BLOCKQUOTE>
<HR>
<TABLE BORDER=0 WIDTH=100% CELLSPACING=0 CELLPADDING=0>
<TR><TD WIDTH=30%><FONT SIZE=-1>Last page update: 27th April, 2010.</FONT></TD>
<TD WIDTH=40% ALIGN=CENTER><A HREF="mailto:leeedavison@googlemail.com">e-mail me 
<IMG SRC="../../eml_sm.png" ALIGN=CENTER BORDER=0 TITLE="e-mail"></A></TD>
<TD WIDTH=30%></TD></TR></TABLE></BODY></HTML>

